services:
  app:
    build:
      context: ./backend # Points to the backend directory where the Dockerfile is located
      dockerfile: Dockerfile # The Dockerfile used to build the application image
    volumes:
      - ./backend:/bot # Mounts the backend directory (source code) into the container for development
    env_file:
      - .env.dev
    expose:
      - "8000" # Exposes port 8000 internally for communication within the Docker network (not publicly exposed)
    networks:
      - internal_network # Connects the app service to the internal network for secure communication with other services

    depends_on:
      - DB # Ensures that the PostgreSQL database starts before the app service

    restart: on-failure

  DB:
    # Explicit Postgres image to satisfy compose requirements
    image: postgres:16-alpine

    volumes:
      - db_data:/var/lib/postgresql/data # Mounts a persistent volume to store PostgreSQL data, ensuring data is not lost on container restart
    env_file:
      - .env.dev # Loads environment variables from a .env file for development
    healthcheck:
      # Use container env vars (from env_file) rather than compose-time substitution
      test: [ "CMD-SHELL", "pg_isready -U $$DB_USER -d $$DB" ] # Health check command to ensure PostgreSQL is ready
      interval: 5s # Checks the database every 5 seconds
      timeout: 5s # Timeout for the health check
      retries: 5 # Number of retries before considering the service unhealthy

    networks:
      - internal_network # PostgreSQL service is on the same internal network, allowing only internal services to access it
    restart: always # Ensures PostgreSQL restarts automatically

  pgadmin:
    image: dpage/pgadmin4
    container_name: pgadmin
    env_file:
      - .env.dev
    ports:
      - "5050:80" # Expose pgAdmin on port 5050 of the host
    depends_on:
      DB:
        condition: service_healthy
    networks:
      - internal_network

  migrate:
    build:
      context: ./backend # same image/tooling as app (now using backend directory)
      dockerfile: Dockerfile
    env_file:
      - .env.dev
    depends_on:
      DB:
        condition: service_healthy
    command: alembic upgrade head # apply latest migrations and exit
    restart: "no" # never restart; fail deploy if this fails
    networks:
      - internal_network

  nginx:
    image: nginx:1.27 # Use the latest stable version of NGINX
    volumes:
      - ./nginx/default.dev.conf:/etc/nginx/conf.d/default.conf # Maps the local NGINX configuration file to the container for customization
    ports:
      - "80:80" # Exposes port 80 to the public, allowing external traffic to reach the NGINX server
    depends_on:
      - app # Ensures the app service starts before NGINX begins
    networks:
      - internal_network # Connects NGINX to the internal network to communicate with the app service

  # -----------------------------------------------------------------------------
  # Frontend service
  #
  # This service runs the Next.js based UI that demonstrates how to consume the
  # API exposed by the FastAPI backend.  During development the container
  # runs `npm run dev` to enable hot-reloading.  The `BACKEND_URL`
  # environment variable tells the frontend where to find the API on the docker
  # network.  The port 3000 on the host exposes the development server.
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    volumes:
      - ./frontend:/app
    environment:
      - BACKEND_URL=http://app:8000
      - NODE_ENV=development
    command: npm run dev
    ports:
      - "3000:3000"
    depends_on:
      - app
    networks:
      - internal_network

volumes:
  db_data:
    driver: local # Defines a volume for storing PostgreSQL data persistently

networks:
  internal_network:
    driver: bridge # Creates an internal bridge network for isolated service communication
